import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { SimplifierClient } from "../../src/client/simplifier-client.js";
import { registerConnectorTools } from "../../src/tools/connector-tools.js";
import { wrapToolResult } from "../../src/tools/toolresult.js";
import { SimplifierConnectorDetails, SimplifierConnectorUpdate, SimplifierConnectorCallUpdate, SimplifierConnectorCallDetails, ConnectorTestResponse } from "../../src/client/types.js";
import { readFile } from "../../src/resourceprovider.js";

// Mock the wrapToolResult function
jest.mock("../../src/tools/toolresult.js", () => ({
  wrapToolResult: jest.fn()
}));

// Mock the resourceprovider
jest.mock("../../src/resourceprovider.js", () => ({
  readFile: jest.fn()
}));

describe('registerConnectorTools', () => {
  let mockServer: jest.Mocked<McpServer>;
  let mockSimplifierClient: jest.Mocked<SimplifierClient>;
  let mockWrapToolResult: jest.MockedFunction<typeof wrapToolResult>;
  let mockReadFile: jest.MockedFunction<typeof readFile>;

  beforeEach(() => {
    // Create a mock McpServer
    mockServer = {
      tool: jest.fn()
    } as any;

    // Create a mock SimplifierClient
    mockSimplifierClient = {
      getConnector: jest.fn(),
      createConnector: jest.fn(),
      updateConnector: jest.fn(),
      getConnectorCall: jest.fn(),
      createConnectorCall: jest.fn(),
      updateConnectorCall: jest.fn(),
      testConnectorCall: jest.fn(),
      deleteConnectorCall: jest.fn(),
      deleteConnector: jest.fn()
    } as any;

    // Get the mocked functions
    mockWrapToolResult = wrapToolResult as jest.MockedFunction<typeof wrapToolResult>;
    mockReadFile = readFile as jest.MockedFunction<typeof readFile>;

    // Setup default mock for readFile
    mockReadFile.mockReturnValue("This is the connector documentation content");

    // Clear all mocks
    jest.clearAllMocks();
  });

  describe('function registration', () => {
    it('should register all five connector tools', () => {
      registerConnectorTools(mockServer, mockSimplifierClient);

      expect(mockServer.tool).toHaveBeenCalledTimes(5);

      // Check that readFile was called with the correct paths
      expect(mockReadFile).toHaveBeenCalledWith("tools/docs/create-or-update-connector.md");
      expect(mockReadFile).toHaveBeenCalledWith("tools/docs/create-or-update-connectorcall.md");

      // Check the connector-update tool registration
      expect(mockServer.tool).toHaveBeenCalledWith(
        "connector-update",
        "This is the connector documentation content",
        expect.objectContaining({
          name: expect.any(Object),
          description: expect.any(Object),
          tags: expect.any(Object),
          projectsBefore: expect.any(Object),
          projectsAfterChange: expect.any(Object),
          connectorType: expect.any(Object),
          active: expect.any(Object),
          endpointConfiguration: expect.any(Object)
        }),
        expect.objectContaining({
          title: "Create or update a Connector",
          readOnlyHint: false,
          destructiveHint: false,
          idempotentHint: false,
          openWorldHint: true
        }),
        expect.any(Function)
      );

      // Check the connector-call-update tool registration
      expect(mockServer.tool).toHaveBeenCalledWith(
        "connector-call-update",
        "This is the connector documentation content",
        expect.objectContaining({
          connectorName: expect.any(Object),
          connectorCallName: expect.any(Object),
          description: expect.any(Object),
          validateIn: expect.any(Object),
          validateOut: expect.any(Object),
          async: expect.any(Object),
          autoGenerated: expect.any(Object),
          connectorCallParameters: expect.any(Object)
        }),
        expect.objectContaining({
          title: "Create or update a Connector Call",
          readOnlyHint: false,
          destructiveHint: false,
          idempotentHint: false,
          openWorldHint: true
        }),
        expect.any(Function)
      );

      // Check connector-call-test tool registration
      expect(mockServer.tool).toHaveBeenCalledWith(
        "connector-call-test",
        expect.any(String),
        expect.objectContaining({
          connectorName: expect.any(Object),
          callName: expect.any(Object),
          parameters: expect.any(Object)
        }),
        expect.objectContaining({
          title: "Test a Connector Call",
          readOnlyHint: true,
          destructiveHint: false,
          idempotentHint: true,
          openWorldHint: false
        }),
        expect.any(Function)
      );

      // Check fourth tool (connector-call-delete)
      expect(mockServer.tool).toHaveBeenNthCalledWith(4,
        "connector-call-delete",
        expect.any(String),
        expect.objectContaining({
          connectorName: expect.any(Object),
          callName: expect.any(Object)
        }),
        expect.objectContaining({
          title: "Delete a Connector Call",
          readOnlyHint: false,
          destructiveHint: true,
          idempotentHint: true,
          openWorldHint: false
        }),
        expect.any(Function)
      );

      // Check fifth tool (connector-delete)
      expect(mockServer.tool).toHaveBeenNthCalledWith(5,
        "connector-delete",
        expect.any(String),
        expect.objectContaining({
          connectorName: expect.any(Object)
        }),
        expect.objectContaining({
          title: "Delete a Connector",
          readOnlyHint: false,
          destructiveHint: true,
          idempotentHint: true,
          openWorldHint: false
        }),
        expect.any(Function)
      );
    });
  });

  describe('connector-update tool', () => {
    describe('schema validation', () => {
      it('should validate required schema fields', () => {
        registerConnectorTools(mockServer, mockSimplifierClient);

        const toolCall = mockServer.tool.mock.calls[0];
        const schema = toolCall[2];

        // Test that schema validates required fields
        expect(schema.name).toBeDefined();
        expect(schema.description).toBeDefined();
        expect(schema.tags).toBeDefined();
        expect(schema.projectsBefore).toBeDefined();
        expect(schema.projectsAfterChange).toBeDefined();
        expect(schema.connectorType).toBeDefined();
        expect(schema.active).toBeDefined();
        expect(schema.endpointConfiguration).toBeDefined();

        // Test valid data passes validation - each field individually
        const validName = "TestConnector";
        const validDescription = "Test connector description";
        const validTags = ["test", "connector"];
        const validProjectsBefore = ["Project1"];
        const validProjectsAfterChange = ["Project1", "Project2"];
        const validConnectorType = "REST";
        const validActive = true;
        const validEndpointConfiguration = {
          endpoint: "https://api.example.com",
          certificates: [],
          configuration: {},
          loginMethodName: "basicAuth"
        };

        expect(() => schema.name.parse(validName)).not.toThrow();
        expect(() => schema.description.parse(validDescription)).not.toThrow();
        expect(() => schema.tags.parse(validTags)).not.toThrow();
        expect(() => schema.projectsBefore.parse(validProjectsBefore)).not.toThrow();
        expect(() => schema.projectsAfterChange.parse(validProjectsAfterChange)).not.toThrow();
        expect(() => schema.connectorType.parse(validConnectorType)).not.toThrow();
        expect(() => schema.active.parse(validActive)).not.toThrow();
        expect(() => schema.endpointConfiguration.parse(validEndpointConfiguration)).not.toThrow();
      });

      it('should validate that name and connectorType are required', () => {
        registerConnectorTools(mockServer, mockSimplifierClient);

        const toolCall = mockServer.tool.mock.calls[0];
        const schema = toolCall[2];

        // Test that valid string passes
        expect(() => schema.name.parse("ValidName")).not.toThrow();
        expect(() => schema.connectorType.parse("REST")).not.toThrow();

        // Test that undefined fails validation for required fields
        expect(() => schema.name.parse(undefined)).toThrow();
        expect(() => schema.connectorType.parse(undefined)).toThrow();

        // Test that null fails validation
        expect(() => schema.name.parse(null)).toThrow();
        expect(() => schema.connectorType.parse(null)).toThrow();
      });

      it('should allow optional fields to be omitted with defaults', () => {
        registerConnectorTools(mockServer, mockSimplifierClient);

        const toolCall = mockServer.tool.mock.calls[0];
        const schema = toolCall[2];

        // Test that optional fields can be undefined and get defaults
        expect(() => schema.description.parse(undefined)).not.toThrow();
        expect(() => schema.tags.parse(undefined)).not.toThrow();
        expect(() => schema.projectsBefore.parse(undefined)).not.toThrow();
        expect(() => schema.projectsAfterChange.parse(undefined)).not.toThrow();
        expect(() => schema.active.parse(undefined)).not.toThrow();

        // Test default values are applied
        expect(schema.description.parse(undefined)).toBe("");
        expect(schema.tags.parse(undefined)).toEqual([]);
        expect(schema.projectsBefore.parse(undefined)).toEqual([]);
        expect(schema.projectsAfterChange.parse(undefined)).toEqual([]);
        expect(schema.active.parse(undefined)).toBe(true);
      });

      it('should validate endpointConfiguration structure', () => {
        registerConnectorTools(mockServer, mockSimplifierClient);

        const toolCall = mockServer.tool.mock.calls[0];
        const schema = toolCall[2];

        // Valid endpoint configuration
        const validConfig = {
          endpoint: "https://api.example.com",
          certificates: ["cert1", "cert2"],
          configuration: { key: "value" },
          loginMethodName: "oauth2"
        };

        expect(() => schema.endpointConfiguration.parse(validConfig)).not.toThrow();

        // Minimal valid configuration (only required fields)
        const minimalConfig = {
          endpoint: "https://api.example.com",
          certificates: []
        };

        expect(() => schema.endpointConfiguration.parse(minimalConfig)).not.toThrow();

        // Invalid configuration (missing required endpoint)
        const invalidConfig = {
          certificates: []
        };

        expect(() => schema.endpointConfiguration.parse(invalidConfig)).toThrow();
      });
    });

    describe('tool handler - create new connector', () => {
      let toolHandler: Function;

      beforeEach(() => {
        registerConnectorTools(mockServer, mockSimplifierClient);
        toolHandler = mockServer.tool.mock.calls[0][4];
      });

      it('should create a new connector when it does not exist', async () => {
        const testParams = {
          name: "NewConnector",
          description: "New connector description",
          connectorType: "REST",
          active: true,
          endpointConfiguration: {
            endpoint: "https://api.example.com",
            certificates: [],
            configuration: {
              specificConfig1: "TEST",
              specificConfig2: "TEST"
            },
            loginMethodName: "basicAuth"
          },
          tags: ["new", "test"],
          projectsBefore: [],
          projectsAfterChange: ["Project1"]
        };

        const expectedData: SimplifierConnectorUpdate = {
          name: "NewConnector",
          description: "New connector description",
          connectorType: "REST",
          active: true,
          endpointConfiguration: {
            endpoint: "https://api.example.com",
            certificates: [],
            configuration: {
              specificConfig1: "TEST",
              specificConfig2: "TEST"
            },
            loginMethodName: "basicAuth"
          },
          tags: ["new", "test"],
          assignedProjects: {
            projectsBefore: [],
            projectsAfterChange: ["Project1"]
          },
          timeoutTime: 0  // Will be added by the actual implementation if needed
        };

        const expectedResponse = "Connector created successfully";

        // Mock that connector doesn't exist (throws error)
        mockSimplifierClient.getConnector.mockRejectedValue(
          new Error("Not found")
        );

        // Mock successful creation
        mockSimplifierClient.createConnector.mockResolvedValue(expectedResponse);

        // Mock wrapToolResult to call the function and return result
        mockWrapToolResult.mockImplementation(async (_caption, fn) => {
          const result = await fn();
          return {
            content: [{ type: "text", text: JSON.stringify(result, null, 2) }]
          };
        });

        await toolHandler(testParams);

        expect(mockSimplifierClient.getConnector).toHaveBeenCalledWith("NewConnector", "MCP Tool: connector-update");
        expect(mockSimplifierClient.createConnector).toHaveBeenCalledWith(expect.objectContaining({
          name: expectedData.name,
          description: expectedData.description,
          connectorType: expectedData.connectorType,
          active: expectedData.active,
          endpointConfiguration: expectedData.endpointConfiguration,
          tags: expectedData.tags,
          assignedProjects: expectedData.assignedProjects
        }));
        expect(mockSimplifierClient.updateConnector).not.toHaveBeenCalled();
        expect(mockWrapToolResult).toHaveBeenCalledWith(
          "create or update Connector NewConnector",
          expect.any(Function)
        );
      });

      it('should update existing connector when it exists', async () => {
        const testParams = {
          name: "ExistingConnector",
          description: "Updated connector description",
          connectorType: "SOAP",
          active: false,
          endpointConfiguration: {
            endpoint: "https://api.updated.com",
            certificates: ["cert1"],
            configuration: { timeout: 5000 }
          },
          tags: ["updated"],
          projectsBefore: ["Project1"],
          projectsAfterChange: ["Project1", "Project2"]
        };

        const existingConnector: SimplifierConnectorDetails = {
          name: "ExistingConnector",
          description: "Old description",
          connectorType: {
            technicalName: "REST",
            i18n: "REST Connector",
            descriptionI18n: "REST API Connector"
          },
          active: true,
          timeoutTime: 30000,
          amountOfCalls: 10,
          editable: true,
          deletable: true,
          tags: ["old"],
          assignedProjects: {
            projectsBefore: ["Project1"],
            projectsAfterChange: ["Project1"]
          },
          configuration: {
            endpoints: [{
              endpoint: "https://api.old.com",
              certificates: [],
              configuration: {}
            }]
          }
        };

        const expectedResponse = "Connector updated successfully";

        // Mock that connector exists
        mockSimplifierClient.getConnector.mockResolvedValue(existingConnector);

        // Mock successful update
        mockSimplifierClient.updateConnector.mockResolvedValue(expectedResponse);

        // Mock wrapToolResult
        mockWrapToolResult.mockImplementation(async (_caption, fn) => {
          const result = await fn();
          return {
            content: [{ type: "text", text: JSON.stringify(result, null, 2) }]
          };
        });

        await toolHandler(testParams);

        expect(mockSimplifierClient.getConnector).toHaveBeenCalledWith("ExistingConnector", "MCP Tool: connector-update");
        expect(mockSimplifierClient.updateConnector).toHaveBeenCalledWith(expect.objectContaining({
          name: "ExistingConnector",
          description: "Updated connector description",
          connectorType: "SOAP",
          active: false,
          endpointConfiguration: testParams.endpointConfiguration,
          tags: ["updated"],
          assignedProjects: {
            projectsBefore: ["Project1"],
            projectsAfterChange: ["Project1", "Project2"]
          }
        }));
        expect(mockSimplifierClient.createConnector).not.toHaveBeenCalled();
        expect(mockWrapToolResult).toHaveBeenCalledWith(
          "create or update Connector ExistingConnector",
          expect.any(Function)
        );
      });

      it('should handle errors gracefully', async () => {
        const testParams = {
          name: "ErrorConnector",
          description: "Test error handling",
          connectorType: "REST",
          active: true,
          endpointConfiguration: {
            endpoint: "https://api.error.com",
            certificates: []
          },
          tags: [],
          projectsBefore: [],
          projectsAfterChange: []
        };

        const errorMessage = "API Error: Unable to create connector";

        // Mock that connector doesn't exist
        mockSimplifierClient.getConnector.mockRejectedValue(new Error("Not found"));

        // Mock creation failure
        mockSimplifierClient.createConnector.mockRejectedValue(new Error(errorMessage));

        // Mock wrapToolResult to catch and handle errors
        mockWrapToolResult.mockImplementation(async (caption, fn) => {
          try {
            const result = await fn();
            return {
              content: [{ type: "text", text: JSON.stringify(result, null, 2) }]
            };
          } catch (error) {
            return {
              content: [{
                type: "text",
                text: JSON.stringify({ error: `Tool ${caption} failed: ${error}` })
              }],
              isError: true
            };
          }
        });

        const result = await toolHandler(testParams);

        expect(mockSimplifierClient.getConnector).toHaveBeenCalledWith("ErrorConnector", "MCP Tool: connector-update");
        expect(mockSimplifierClient.createConnector).toHaveBeenCalledWith(expect.any(Object));
        expect(result.isError).toBe(true);
        expect(result.content[0].text).toContain("failed");
      });

      it('should handle complex endpoint configurations', async () => {
        const testParams = {
          name: "ComplexConnector",
          description: "Complex configuration test",
          connectorType: "OAUTH2",
          active: true,
          endpointConfiguration: {
            endpoint: "https://oauth.example.com",
            certificates: ["cert1", "cert2", "cert3"],
            configuration: {
              clientId: "test-client-id",
              clientSecret: "test-secret",
              scope: "read write",
              grantType: "authorization_code",
              redirectUri: "https://callback.example.com"
            },
            loginMethodName: "oauth2Login"
          },
          tags: ["oauth", "complex", "secure"],
          projectsBefore: ["ProjectA", "ProjectB"],
          projectsAfterChange: ["ProjectA", "ProjectC", "ProjectD"]
        };

        // Mock that connector doesn't exist
        mockSimplifierClient.getConnector.mockRejectedValue(new Error("Not found"));

        // Mock successful creation
        mockSimplifierClient.createConnector.mockResolvedValue("Complex connector created");

        // Mock wrapToolResult
        mockWrapToolResult.mockImplementation(async (_caption, fn) => {
          const result = await fn();
          return {
            content: [{ type: "text", text: JSON.stringify(result, null, 2) }]
          };
        });

        await toolHandler(testParams);

        expect(mockSimplifierClient.createConnector).toHaveBeenCalledWith(
          expect.objectContaining({
            endpointConfiguration: testParams.endpointConfiguration
          })
        );
      });
    });

    describe('tool handler - correct create/update logic', () => {
      let toolHandler: Function;

      beforeEach(() => {
        registerConnectorTools(mockServer, mockSimplifierClient);
        toolHandler = mockServer.tool.mock.calls[0][4];
      });

      it('should correctly handle create and update operations', async () => {
        // This test verifies that the create/update logic works correctly:
        // When connector exists, it should call updateConnector
        // When connector doesn't exist, it should call createConnector

        const testParams = {
          name: "TestConnector",
          description: "Testing correct logic",
          connectorType: "REST",
          active: true,
          endpointConfiguration: {
            endpoint: "https://test.com",
            certificates: []
          },
          tags: [],
          projectsBefore: [],
          projectsAfterChange: []
        };

        // Case 1: Connector exists - should call updateConnector
        const existingConnector = {
          name: "TestConnector",
          description: "Existing",
          connectorType: { technicalName: "REST", i18n: "REST", descriptionI18n: "REST" },
          active: true,
          timeoutTime: 30000,
          amountOfCalls: 0,
          editable: true,
          deletable: true,
          tags: [],
          assignedProjects: { projectsBefore: [], projectsAfterChange: [] }
        };

        mockSimplifierClient.getConnector.mockResolvedValue(existingConnector);
        mockSimplifierClient.updateConnector.mockResolvedValue("Updated");
        mockWrapToolResult.mockImplementation(async (_caption, fn) => {
          const result = await fn();
          return { content: [{ type: "text", text: JSON.stringify(result, null, 2) }] };
        });

        await toolHandler(testParams);

        // Should correctly call updateConnector when connector exists
        expect(mockSimplifierClient.updateConnector).toHaveBeenCalled();
        expect(mockSimplifierClient.createConnector).not.toHaveBeenCalled();

        // Reset mocks
        jest.clearAllMocks();

        // Case 2: Connector doesn't exist - should call createConnector
        mockSimplifierClient.getConnector.mockRejectedValue(new Error("Not found"));
        mockSimplifierClient.createConnector.mockResolvedValue("Created");

        await toolHandler(testParams);

        // Should correctly call createConnector when connector doesn't exist
        expect(mockSimplifierClient.createConnector).toHaveBeenCalled();
        expect(mockSimplifierClient.updateConnector).not.toHaveBeenCalled();
      });
    });
  });

  describe('connector-call-update tool', () => {
    describe('schema validation', () => {
      it('should validate required schema fields', () => {
        registerConnectorTools(mockServer, mockSimplifierClient);

        const toolCall = mockServer.tool.mock.calls[1];
        const schema = toolCall[2];

        // Test that schema validates required fields
        expect(schema.connectorName).toBeDefined();
        expect(schema.connectorCallName).toBeDefined();
        expect(schema.description).toBeDefined();
        expect(schema.validateIn).toBeDefined();
        expect(schema.validateOut).toBeDefined();
        expect(schema.async).toBeDefined();
        expect(schema.autoGenerated).toBeDefined();
        expect(schema.connectorCallParameters).toBeDefined();

        // Test valid data passes validation
        const validConnectorName = "TestConnector";
        const validCallName = "testCall";
        const validDescription = "Test call description";

        expect(() => schema.connectorName.parse(validConnectorName)).not.toThrow();
        expect(() => schema.connectorCallName.parse(validCallName)).not.toThrow();
        expect(() => schema.description.parse(validDescription)).not.toThrow();
      });

      it('should validate that connectorName and connectorCallName are required', () => {
        registerConnectorTools(mockServer, mockSimplifierClient);

        const toolCall = mockServer.tool.mock.calls[1];
        const schema = toolCall[2];

        // Test that valid strings pass
        expect(() => schema.connectorName.parse("ValidConnector")).not.toThrow();
        expect(() => schema.connectorCallName.parse("validCall")).not.toThrow();

        // Test that undefined fails validation for required fields
        expect(() => schema.connectorName.parse(undefined)).toThrow();
        expect(() => schema.connectorCallName.parse(undefined)).toThrow();

        // Test that null fails validation
        expect(() => schema.connectorName.parse(null)).toThrow();
        expect(() => schema.connectorCallName.parse(null)).toThrow();
      });

      it('should allow optional fields to be omitted with defaults', () => {
        registerConnectorTools(mockServer, mockSimplifierClient);

        const toolCall = mockServer.tool.mock.calls[1];
        const schema = toolCall[2];

        // Test that optional fields can be undefined and get defaults
        expect(() => schema.description.parse(undefined)).not.toThrow();
        expect(() => schema.validateIn.parse(undefined)).not.toThrow();
        expect(() => schema.validateOut.parse(undefined)).not.toThrow();
        expect(() => schema.async.parse(undefined)).not.toThrow();
        expect(() => schema.autoGenerated.parse(undefined)).not.toThrow();
        expect(() => schema.connectorCallParameters.parse(undefined)).not.toThrow();

        // Test default values are applied
        expect(schema.description.parse(undefined)).toBe("");
        expect(schema.validateIn.parse(undefined)).toBe(true);
        expect(schema.validateOut.parse(undefined)).toBe(true);
        expect(schema.async.parse(undefined)).toBe(false);
        expect(schema.autoGenerated.parse(undefined)).toBe(false);
        expect(schema.connectorCallParameters.parse(undefined)).toEqual([]);
      });

      it('should validate connectorCallParameters structure', () => {
        registerConnectorTools(mockServer, mockSimplifierClient);

        const toolCall = mockServer.tool.mock.calls[1];
        const schema = toolCall[2];

        // Valid parameter
        const validParameter = {
          name: "inputParam",
          alias: "input",
          isInput: true,
          constValue: "constant",
          dataType: {
            name: "String",
            nameSpace: "base",
            category: "base"
          },
          optional: false,
          position: 0
        };

        expect(() => schema.connectorCallParameters.parse([validParameter])).not.toThrow();

        // Minimal valid parameter (only required fields)
        const minimalParameter = {
          name: "param1",
          isInput: true,
          dataType: {
            name: "Integer",
            category: "base"
          }
        };

        expect(() => schema.connectorCallParameters.parse([minimalParameter])).not.toThrow();

        // Invalid parameter (missing required name)
        const invalidParameter = {
          isInput: true,
          dataType: {
            name: "String",
            category: "base"
          }
        };

        expect(() => schema.connectorCallParameters.parse([invalidParameter])).toThrow();
      });

      it('should validate dataType category enum', () => {
        registerConnectorTools(mockServer, mockSimplifierClient);

        const toolCall = mockServer.tool.mock.calls[1];
        const schema = toolCall[2];

        // Test valid categories
        const validCategories = ['base', 'domain', 'collection', 'structure'];

        validCategories.forEach(category => {
          const parameter = {
            name: "test",
            isInput: true,
            dataType: {
              name: "TestType",
              category: category
            }
          };
          expect(() => schema.connectorCallParameters.parse([parameter])).not.toThrow();
        });

        // Test invalid category
        const invalidCategoryParameter = {
          name: "test",
          isInput: true,
          dataType: {
            name: "TestType",
            category: "invalid"
          }
        };

        expect(() => schema.connectorCallParameters.parse([invalidCategoryParameter])).toThrow();
      });

      it('should validate parameter with special name characters', () => {
        registerConnectorTools(mockServer, mockSimplifierClient);

        const toolCall = mockServer.tool.mock.calls[1];
        const schema = toolCall[2];

        // Test parameter names with special characters (/, [])
        const specialNameParameters = [
          {
            name: "root/nested/value",
            isInput: true,
            dataType: { name: "String", category: "base" }
          },
          {
            name: "array[]",
            isInput: false,
            dataType: { name: "Integer", category: "base" }
          },
          {
            name: "complex[]/nested/path",
            isInput: true,
            dataType: { name: "Object", category: "structure" }
          }
        ];

        expect(() => schema.connectorCallParameters.parse(specialNameParameters)).not.toThrow();
      });
    });

    describe('tool handler - create new connector call', () => {
      let toolHandler: Function;

      beforeEach(() => {
        registerConnectorTools(mockServer, mockSimplifierClient);
        toolHandler = mockServer.tool.mock.calls[1][4];
      });

      it('should create a new connector call when it does not exist', async () => {
        const testParams = {
          connectorName: "TestConnector",
          connectorCallName: "newCall",
          description: "New call description",
          validateIn: true,
          validateOut: true,
          async: false,
          autoGenerated: false,
          connectorCallParameters: [
            {
              name: "inputParam",
              alias: "input",
              isInput: true,
              dataType: {
                name: "String",
                nameSpace: "base",
                category: "base"
              },
              optional: false,
              position: 0
            },
            {
              name: "outputParam",
              isInput: false,
              dataType: {
                name: "Integer",
                category: "base"
              },
              optional: false,
              position: 1
            }
          ]
        };

        const expectedData: SimplifierConnectorCallUpdate = {
          name: "newCall",
          description: "New call description",
          validateIn: true,
          validateOut: true,
          async: false,
          autoGenerated: false,
          connectorCallParameters: testParams.connectorCallParameters
        };

        const expectedResponse = "Connector call created successfully";

        // Mock that connector call doesn't exist (throws error)
        mockSimplifierClient.getConnectorCall.mockRejectedValue(
          new Error("Not found")
        );

        // Mock successful creation
        mockSimplifierClient.createConnectorCall.mockResolvedValue(expectedResponse);

        // Mock wrapToolResult to call the function and return result
        mockWrapToolResult.mockImplementation(async (_caption, fn) => {
          const result = await fn();
          return {
            content: [{ type: "text", text: JSON.stringify(result, null, 2) }]
          };
        });

        await toolHandler(testParams);

        expect(mockSimplifierClient.getConnectorCall).toHaveBeenCalledWith("TestConnector", "newCall", "MCP Tool: connector-call-update");
        expect(mockSimplifierClient.createConnectorCall).toHaveBeenCalledWith(
          "TestConnector",
          expect.objectContaining({
            name: expectedData.name,
            description: expectedData.description,
            validateIn: expectedData.validateIn,
            validateOut: expectedData.validateOut,
            async: expectedData.async,
            autoGenerated: expectedData.autoGenerated,
            connectorCallParameters: expectedData.connectorCallParameters
          })
        );
        expect(mockSimplifierClient.updateConnectorCall).not.toHaveBeenCalled();
        expect(mockWrapToolResult).toHaveBeenCalledWith(
          "create or update Connector call TestConnector.newCall",
          expect.any(Function)
        );
      });

      it('should create a connector call with minimal parameters', async () => {
        const testParams = {
          connectorName: "MinimalConnector",
          connectorCallName: "minimalCall",
          description: "",
          validateIn: true,
          validateOut: true,
          async: false,
          autoGenerated: false,
          connectorCallParameters: []
        };

        // Mock that connector call doesn't exist
        mockSimplifierClient.getConnectorCall.mockRejectedValue(new Error("Not found"));

        // Mock successful creation
        mockSimplifierClient.createConnectorCall.mockResolvedValue("Created");

        // Mock wrapToolResult
        mockWrapToolResult.mockImplementation(async (_caption, fn) => {
          const result = await fn();
          return {
            content: [{ type: "text", text: JSON.stringify(result, null, 2) }]
          };
        });

        await toolHandler(testParams);

        expect(mockSimplifierClient.createConnectorCall).toHaveBeenCalledWith(
          "MinimalConnector",
          expect.objectContaining({
            name: "minimalCall",
            description: "",
            connectorCallParameters: []
          })
        );
      });

      it('should create a connector call with complex parameters', async () => {
        const testParams = {
          connectorName: "ComplexConnector",
          connectorCallName: "complexCall",
          description: "Complex call with multiple parameter types",
          validateIn: true,
          validateOut: false,
          async: true,
          autoGenerated: false,
          connectorCallParameters: [
            {
              name: "root/nested/input",
              alias: "nestedInput",
              isInput: true,
              constValue: "constant-value",
              dataType: {
                name: "CustomType",
                nameSpace: "custom",
                category: "domain"
              },
              optional: true,
              position: 0
            },
            {
              name: "array[]",
              isInput: true,
              dataType: {
                name: "StringArray",
                category: "collection"
              },
              optional: false,
              position: 1
            },
            {
              name: "structOutput",
              isInput: false,
              dataType: {
                name: "ComplexStruct",
                nameSpace: "structures",
                category: "structure"
              },
              optional: false,
              position: 2
            }
          ]
        };

        // Mock that connector call doesn't exist
        mockSimplifierClient.getConnectorCall.mockRejectedValue(new Error("Not found"));

        // Mock successful creation
        mockSimplifierClient.createConnectorCall.mockResolvedValue("Complex call created");

        // Mock wrapToolResult
        mockWrapToolResult.mockImplementation(async (_caption, fn) => {
          const result = await fn();
          return {
            content: [{ type: "text", text: JSON.stringify(result, null, 2) }]
          };
        });

        await toolHandler(testParams);

        expect(mockSimplifierClient.createConnectorCall).toHaveBeenCalledWith(
          "ComplexConnector",
          expect.objectContaining({
            name: "complexCall",
            async: true,
            connectorCallParameters: testParams.connectorCallParameters
          })
        );
      });
    });

    describe('tool handler - update existing connector call', () => {
      let toolHandler: Function;

      beforeEach(() => {
        registerConnectorTools(mockServer, mockSimplifierClient);
        toolHandler = mockServer.tool.mock.calls[1][4];
      });

      it('should update existing connector call when it exists', async () => {
        const testParams = {
          connectorName: "ExistingConnector",
          connectorCallName: "existingCall",
          description: "Updated call description",
          validateIn: false,
          validateOut: true,
          async: true,
          autoGenerated: false,
          connectorCallParameters: [
            {
              name: "updatedParam",
              isInput: true,
              dataType: {
                name: "Boolean",
                category: "base"
              },
              optional: true,
              position: 0
            }
          ]
        };

        const existingCall: SimplifierConnectorCallDetails = {
          name: "existingCall",
          description: "Old description",
          validateIn: true,
          validateOut: false,
          async: false,
          autoGenerated: false,
          editable: true,
          executable: true,
          connectorName: "ExistingConnector",
          connectorCallParameters: [
            {
              name: "oldParam",
              isInput: true,
              dataType: {
                name: "String",
                category: "base"
              },
              optional: false,
              position: 0
            }
          ]
        };

        const expectedResponse = "Connector call updated successfully";

        // Mock that connector call exists
        mockSimplifierClient.getConnectorCall.mockResolvedValue(existingCall);

        // Mock successful update
        mockSimplifierClient.updateConnectorCall.mockResolvedValue(expectedResponse);

        // Mock wrapToolResult
        mockWrapToolResult.mockImplementation(async (_caption, fn) => {
          const result = await fn();
          return {
            content: [{ type: "text", text: JSON.stringify(result, null, 2) }]
          };
        });

        await toolHandler(testParams);

        expect(mockSimplifierClient.getConnectorCall).toHaveBeenCalledWith("ExistingConnector", "existingCall", "MCP Tool: connector-call-update");
        expect(mockSimplifierClient.updateConnectorCall).toHaveBeenCalledWith(
          "ExistingConnector",
          expect.objectContaining({
            name: "existingCall",
            description: "Updated call description",
            validateIn: false,
            validateOut: true,
            async: true,
            autoGenerated: false,
            connectorCallParameters: testParams.connectorCallParameters
          })
        );
        expect(mockSimplifierClient.createConnectorCall).not.toHaveBeenCalled();
        expect(mockWrapToolResult).toHaveBeenCalledWith(
          "create or update Connector call ExistingConnector.existingCall",
          expect.any(Function)
        );
      });

      it('should update connector call with changed parameters', async () => {
        const testParams = {
          connectorName: "TestConnector",
          connectorCallName: "updateCall",
          description: "Call with updated parameters",
          validateIn: true,
          validateOut: true,
          async: false,
          autoGenerated: false,
          connectorCallParameters: [
            {
              name: "newInput1",
              isInput: true,
              dataType: { name: "String", category: "base" },
              optional: false,
              position: 0
            },
            {
              name: "newInput2",
              isInput: true,
              dataType: { name: "Integer", category: "base" },
              optional: true,
              position: 1
            },
            {
              name: "newOutput",
              isInput: false,
              dataType: { name: "Boolean", category: "base" },
              optional: false,
              position: 2
            }
          ]
        };

        const existingCall: SimplifierConnectorCallDetails = {
          name: "updateCall",
          description: "Old description",
          validateIn: true,
          validateOut: true,
          async: false,
          autoGenerated: false,
          editable: true,
          executable: true,
          connectorName: "TestConnector",
          connectorCallParameters: [
            {
              name: "oldParam",
              isInput: true,
              dataType: { name: "String", category: "base" },
              optional: false,
              position: 0
            }
          ]
        };

        // Mock that connector call exists
        mockSimplifierClient.getConnectorCall.mockResolvedValue(existingCall);

        // Mock successful update
        mockSimplifierClient.updateConnectorCall.mockResolvedValue("Updated");

        // Mock wrapToolResult
        mockWrapToolResult.mockImplementation(async (_caption, fn) => {
          const result = await fn();
          return {
            content: [{ type: "text", text: JSON.stringify(result, null, 2) }]
          };
        });

        await toolHandler(testParams);

        expect(mockSimplifierClient.updateConnectorCall).toHaveBeenCalledWith(
          "TestConnector",
          expect.objectContaining({
            connectorCallParameters: testParams.connectorCallParameters
          })
        );
      });

      it('should correctly handle create and update operations', async () => {
        const testParams = {
          connectorName: "TestConnector",
          connectorCallName: "testCall",
          description: "Testing correct logic",
          validateIn: true,
          validateOut: true,
          async: false,
          autoGenerated: false,
          connectorCallParameters: []
        };

        // Case 1: Call exists - should call updateConnectorCall
        const existingCall = {
          name: "testCall",
          description: "Existing",
          validateIn: true,
          validateOut: true,
          async: false,
          autoGenerated: false,
          editable: true,
          executable: true,
          connectorName: "TestConnector",
          connectorCallParameters: []
        };

        mockSimplifierClient.getConnectorCall.mockResolvedValue(existingCall);
        mockSimplifierClient.updateConnectorCall.mockResolvedValue("Updated");
        mockWrapToolResult.mockImplementation(async (_caption, fn) => {
          const result = await fn();
          return { content: [{ type: "text", text: JSON.stringify(result, null, 2) }] };
        });

        await toolHandler(testParams);

        // Should correctly call updateConnectorCall when call exists
        expect(mockSimplifierClient.updateConnectorCall).toHaveBeenCalled();
        expect(mockSimplifierClient.createConnectorCall).not.toHaveBeenCalled();

        // Reset mocks
        jest.clearAllMocks();

        // Case 2: Call doesn't exist - should call createConnectorCall
        mockSimplifierClient.getConnectorCall.mockRejectedValue(new Error("Not found"));
        mockSimplifierClient.createConnectorCall.mockResolvedValue("Created");
        mockWrapToolResult.mockImplementation(async (_caption, fn) => {
          const result = await fn();
          return { content: [{ type: "text", text: JSON.stringify(result, null, 2) }] };
        });

        await toolHandler(testParams);

        // Should correctly call createConnectorCall when call doesn't exist
        expect(mockSimplifierClient.createConnectorCall).toHaveBeenCalled();
        expect(mockSimplifierClient.updateConnectorCall).not.toHaveBeenCalled();
      });
    });

    describe('tool handler - error handling', () => {
      let toolHandler: Function;

      beforeEach(() => {
        registerConnectorTools(mockServer, mockSimplifierClient);
        toolHandler = mockServer.tool.mock.calls[1][4];
      });

      it('should handle errors when creating connector call fails', async () => {
        const testParams = {
          connectorName: "ErrorConnector",
          connectorCallName: "errorCall",
          description: "Test error handling",
          validateIn: true,
          validateOut: true,
          async: false,
          autoGenerated: false,
          connectorCallParameters: []
        };

        const errorMessage = "API Error: Unable to create connector call";

        // Mock that connector call doesn't exist
        mockSimplifierClient.getConnectorCall.mockRejectedValue(new Error("Not found"));

        // Mock creation failure
        mockSimplifierClient.createConnectorCall.mockRejectedValue(new Error(errorMessage));

        // Mock wrapToolResult to catch and handle errors
        mockWrapToolResult.mockImplementation(async (caption, fn) => {
          try {
            const result = await fn();
            return {
              content: [{ type: "text", text: JSON.stringify(result, null, 2) }]
            };
          } catch (error) {
            return {
              content: [{
                type: "text",
                text: JSON.stringify({ error: `Tool ${caption} failed: ${error}` })
              }],
              isError: true
            };
          }
        });

        const result = await toolHandler(testParams);

        expect(mockSimplifierClient.getConnectorCall).toHaveBeenCalledWith("ErrorConnector", "errorCall", "MCP Tool: connector-call-update");
        expect(mockSimplifierClient.createConnectorCall).toHaveBeenCalledWith("ErrorConnector", expect.any(Object));
        expect(result.isError).toBe(true);
        expect(result.content[0].text).toContain("failed");
      });

      it('should handle errors when updating connector call fails', async () => {
        const testParams = {
          connectorName: "ErrorConnector",
          connectorCallName: "errorCall",
          description: "Test update error",
          validateIn: true,
          validateOut: true,
          async: false,
          autoGenerated: false,
          connectorCallParameters: []
        };

        const existingCall = {
          name: "errorCall",
          description: "Existing",
          validateIn: true,
          validateOut: true,
          async: false,
          autoGenerated: false,
          editable: true,
          executable: true,
          connectorName: "ErrorConnector",
          connectorCallParameters: []
        };

        const errorMessage = "API Error: Unable to update connector call";

        // Mock that connector call exists
        mockSimplifierClient.getConnectorCall.mockResolvedValue(existingCall);

        // Mock update failure
        mockSimplifierClient.updateConnectorCall.mockRejectedValue(new Error(errorMessage));

        // Mock wrapToolResult to catch and handle errors
        mockWrapToolResult.mockImplementation(async (caption, fn) => {
          try {
            const result = await fn();
            return {
              content: [{ type: "text", text: JSON.stringify(result, null, 2) }]
            };
          } catch (error) {
            return {
              content: [{
                type: "text",
                text: JSON.stringify({ error: `Tool ${caption} failed: ${error}` })
              }],
              isError: true
            };
          }
        });

        const result = await toolHandler(testParams);

        expect(mockSimplifierClient.getConnectorCall).toHaveBeenCalledWith("ErrorConnector", "errorCall", "MCP Tool: connector-call-update");
        expect(mockSimplifierClient.updateConnectorCall).toHaveBeenCalledWith("ErrorConnector", expect.any(Object));
        expect(result.isError).toBe(true);
        expect(result.content[0].text).toContain("failed");
      });

      it('should handle errors when connector does not exist', async () => {
        const testParams = {
          connectorName: "NonExistentConnector",
          connectorCallName: "testCall",
          description: "Test on non-existent connector",
          validateIn: true,
          validateOut: true,
          async: false,
          autoGenerated: false,
          connectorCallParameters: []
        };

        // Mock that connector call doesn't exist
        mockSimplifierClient.getConnectorCall.mockRejectedValue(new Error("Not found"));

        // Mock that connector doesn't exist
        mockSimplifierClient.createConnectorCall.mockRejectedValue(
          new Error("Connector 'NonExistentConnector' does not exist")
        );

        // Mock wrapToolResult to catch and handle errors
        mockWrapToolResult.mockImplementation(async (caption, fn) => {
          try {
            const result = await fn();
            return {
              content: [{ type: "text", text: JSON.stringify(result, null, 2) }]
            };
          } catch (error) {
            return {
              content: [{
                type: "text",
                text: JSON.stringify({ error: `Tool ${caption} failed: ${error}` })
              }],
              isError: true
            };
          }
        });

        const result = await toolHandler(testParams);

        expect(result.isError).toBe(true);
        expect(result.content[0].text).toContain("NonExistentConnector");
      });
    });
  });

  describe('connector-call-test tool', () => {
    describe('schema validation', () => {
      it('should validate required schema fields', () => {
        registerConnectorTools(mockServer, mockSimplifierClient);

        const toolCall = mockServer.tool.mock.calls[2];
        const schema = toolCall[2];

        // Test that schema validates required fields
        expect(schema.connectorName).toBeDefined();
        expect(schema.callName).toBeDefined();
        expect(schema.parameters).toBeDefined();

        // Test valid data passes validation
        expect(() => schema.connectorName.parse("TestConnector")).not.toThrow();
        expect(() => schema.callName.parse("testCall")).not.toThrow();
        expect(() => schema.parameters.parse([{ name: "param1", value: "test" }])).not.toThrow();
      });

      it('should validate that connectorName and callName are required', () => {
        registerConnectorTools(mockServer, mockSimplifierClient);

        const toolCall = mockServer.tool.mock.calls[2];
        const schema = toolCall[2];

        // Test that valid strings pass
        expect(() => schema.connectorName.parse("ValidConnector")).not.toThrow();
        expect(() => schema.callName.parse("validCall")).not.toThrow();

        // Test that undefined fails validation
        expect(() => schema.connectorName.parse(undefined)).toThrow();
        expect(() => schema.callName.parse(undefined)).toThrow();

        // Test that null fails validation
        expect(() => schema.connectorName.parse(null)).toThrow();
        expect(() => schema.callName.parse(null)).toThrow();
      });

      it('should allow parameters to be optional with empty array default', () => {
        registerConnectorTools(mockServer, mockSimplifierClient);

        const toolCall = mockServer.tool.mock.calls[2];
        const schema = toolCall[2];

        // Test that parameters can be undefined and defaults to empty array
        expect(() => schema.parameters.parse(undefined)).not.toThrow();
        expect(schema.parameters.parse(undefined)).toEqual([]);
      });

      it('should validate parameter structure', () => {
        registerConnectorTools(mockServer, mockSimplifierClient);

        const toolCall = mockServer.tool.mock.calls[2];
        const schema = toolCall[2];

        // Test valid parameter structure
        const validParameters = [
          { name: "param1", value: "value1" },
          { name: "param2", value: 123 }
        ];
        expect(() => schema.parameters.parse(validParameters)).not.toThrow();

        // Test that parameters require a name
        const invalidParameters = [
          { value: "value1" } // Missing name
        ];
        expect(() => schema.parameters.parse(invalidParameters)).toThrow();
      });

      it('should allow any value type in parameters', () => {
        registerConnectorTools(mockServer, mockSimplifierClient);

        const toolCall = mockServer.tool.mock.calls[2];
        const schema = toolCall[2];

        const parametersWithVariousValues = [
          { name: "string", value: "text" },
          { name: "number", value: 42 },
          { name: "boolean", value: false },
          { name: "null", value: null },
          { name: "undefined", value: undefined },
          { name: "object", value: { nested: "object" } },
          { name: "array", value: [1, 2, 3] }
        ];

        expect(() => schema.parameters.parse(parametersWithVariousValues)).not.toThrow();
      });
    });

    describe('tool handler - test connector call', () => {
      let toolHandler: Function;

      beforeEach(() => {
        registerConnectorTools(mockServer, mockSimplifierClient);
        toolHandler = mockServer.tool.mock.calls[2][4];
      });

      it('should test connector call successfully with no parameters', async () => {
        const testParams = {
          connectorName: "TestConnector",
          callName: "simpleCall",
          parameters: []
        };

        // Mock the connector call details with no parameters
        const mockConnectorCall: SimplifierConnectorCallDetails = {
          name: "simpleCall",
          description: "Simple call",
          validateIn: true,
          validateOut: true,
          async: false,
          autoGenerated: false,
          editable: true,
          executable: true,
          connectorName: "TestConnector",
          connectorCallParameters: []
        };

        mockSimplifierClient.getConnectorCall.mockResolvedValue(mockConnectorCall);

        const mockResponse: ConnectorTestResponse = {
          success: true,
          result: { result: { message: "Success" } }
        };

        mockSimplifierClient.testConnectorCall.mockResolvedValue(mockResponse);

        mockWrapToolResult.mockImplementation(async (_caption, fn) => {
          const result = await fn();
          return {
            content: [{ type: "text", text: JSON.stringify(result, null, 2) }]
          };
        });

        await toolHandler(testParams);

        expect(mockSimplifierClient.getConnectorCall).toHaveBeenCalledWith("TestConnector", "simpleCall");
        expect(mockSimplifierClient.testConnectorCall).toHaveBeenCalledWith(
          "TestConnector",
          "simpleCall",
          { parameters: [] },
          "MCP Tool: connector-call-test"
        );
        expect(mockWrapToolResult).toHaveBeenCalledWith(
          "test connector call TestConnector.simpleCall",
          expect.any(Function)
        );
      });

      it('should test connector call successfully with parameters', async () => {
        const testParams = {
          connectorName: "TestConnector",
          callName: "processData",
          parameters: [
            { name: "inputText", value: "Hello World" },
            { name: "count", value: 5 },
            { name: "enabled", value: true }
          ]
        };

        // Mock the connector call details that will be fetched
        const mockConnectorCall: SimplifierConnectorCallDetails = {
          name: "processData",
          description: "Process data",
          validateIn: true,
          validateOut: true,
          async: false,
          autoGenerated: false,
          editable: true,
          executable: true,
          connectorName: "TestConnector",
          connectorCallParameters: [
            {
              name: "inputText",
              isInput: true,
              dataType: { name: "String", category: "base" },
              optional: false,
              position: 0
            },
            {
              name: "count",
              isInput: true,
              dataType: { name: "Integer", category: "base" },
              optional: false,
              position: 1
            },
            {
              name: "enabled",
              isInput: true,
              dataType: { name: "Boolean", category: "base" },
              optional: false,
              position: 2
            }
          ]
        };

        // Mock data types that will be fetched
        const mockStringType = {
          id: "string-id",
          name: "String",
          category: "base",
          description: "String type",
          baseType: "string",
          isStruct: false,
          fields: [],
          properties: []
        };

        const mockIntegerType = {
          id: "integer-id",
          name: "Integer",
          category: "base",
          description: "Integer type",
          baseType: "number",
          isStruct: false,
          fields: [],
          properties: []
        };

        const mockBooleanType = {
          id: "boolean-id",
          name: "Boolean",
          category: "base",
          description: "Boolean type",
          baseType: "boolean",
          isStruct: false,
          fields: [],
          properties: []
        };

        mockSimplifierClient.getConnectorCall.mockResolvedValue(mockConnectorCall);
        mockSimplifierClient.getDataTypeById = jest.fn()
          .mockResolvedValueOnce(mockStringType)
          .mockResolvedValueOnce(mockIntegerType)
          .mockResolvedValueOnce(mockBooleanType);

        const mockResponse: ConnectorTestResponse = {
          success: true,
          result: { result: { processedText: "HELLO WORLD", repeatCount: 5 } }
        };

        mockSimplifierClient.testConnectorCall.mockResolvedValue(mockResponse);

        mockWrapToolResult.mockImplementation(async (_caption, fn) => {
          const result = await fn();
          expect(result.success).toBe(true);
          expect(result.result).toEqual({ result: { processedText: "HELLO WORLD", repeatCount: 5 } });
          return {
            content: [{ type: "text", text: JSON.stringify(result, null, 2) }]
          };
        });

        await toolHandler(testParams);

        expect(mockSimplifierClient.getConnectorCall).toHaveBeenCalledWith("TestConnector", "processData");
        expect(mockSimplifierClient.testConnectorCall).toHaveBeenCalledWith(
          "TestConnector",
          "processData",
          expect.objectContaining({
            parameters: expect.arrayContaining([
              expect.objectContaining({
                name: "inputText",
                value: "Hello World",
                dataType: mockStringType,
                transfer: true
              }),
              expect.objectContaining({
                name: "count",
                value: 5,
                dataType: mockIntegerType,
                transfer: true
              }),
              expect.objectContaining({
                name: "enabled",
                value: true,
                dataType: mockBooleanType,
                transfer: true
              })
            ])
          }),
          "MCP Tool: connector-call-test"
        );
      });

      it('should handle various parameter value types', async () => {
        const testParams = {
          connectorName: "TestConnector",
          callName: "multiTypeCall",
          parameters: [
            { name: "stringParam", value: "text" },
            { name: "numberParam", value: 42 },
            { name: "floatParam", value: 3.14 },
            { name: "booleanParam", value: true },
            { name: "objectParam", value: { key: "value", nested: { data: "test" } } },
            { name: "arrayParam", value: [1, 2, 3] },
            { name: "nullParam", value: null }
          ]
        };

        // Mock the connector call details
        const mockConnectorCall: SimplifierConnectorCallDetails = {
          name: "multiTypeCall",
          description: "Multi type call",
          validateIn: true,
          validateOut: true,
          async: false,
          autoGenerated: false,
          editable: true,
          executable: true,
          connectorName: "TestConnector",
          connectorCallParameters: testParams.parameters.map((p, i) => ({
            name: p.name,
            isInput: true,
            dataType: { name: "Any", category: "base" },
            optional: false,
            position: i
          }))
        };

        const mockDataType = {
          id: "any-id",
          name: "Any",
          category: "base",
          description: "Any type",
          baseType: "any",
          isStruct: false,
          fields: [],
          properties: []
        };

        mockSimplifierClient.getConnectorCall.mockResolvedValue(mockConnectorCall);
        mockSimplifierClient.getDataTypeById = jest.fn().mockResolvedValue(mockDataType);

        const mockResponse: ConnectorTestResponse = {
          success: true,
          result: { result: { status: "processed" } }
        };

        mockSimplifierClient.testConnectorCall.mockResolvedValue(mockResponse);

        mockWrapToolResult.mockImplementation(async (_caption, fn) => {
          await fn();
          return { content: [{ type: "text", text: "Success" }] };
        });

        await toolHandler(testParams);

        expect(mockSimplifierClient.getConnectorCall).toHaveBeenCalledWith("TestConnector", "multiTypeCall");

        // Check that the call was made with transformed parameters
        const call = mockSimplifierClient.testConnectorCall.mock.calls[0];
        expect(call[0]).toBe("TestConnector");
        expect(call[1]).toBe("multiTypeCall");
        expect(call[2].parameters).toHaveLength(testParams.parameters.length);

        // Verify each parameter has the correct structure (excluding null value edge case)
        testParams.parameters.slice(0, -1).forEach((p, i) => {
          expect(call[2].parameters[i]).toMatchObject({
            name: p.name,
            value: p.value,
            dataType: mockDataType,
            transfer: true
          });
        });
      });

      it('should handle connector call execution failure', async () => {
        const testParams = {
          connectorName: "TestConnector",
          callName: "failingCall",
          parameters: []
        };

        // Mock the connector call details
        const mockConnectorCall: SimplifierConnectorCallDetails = {
          name: "failingCall",
          description: "Failing call",
          validateIn: true,
          validateOut: true,
          async: false,
          autoGenerated: false,
          editable: true,
          executable: true,
          connectorName: "TestConnector",
          connectorCallParameters: []
        };

        mockSimplifierClient.getConnectorCall.mockResolvedValue(mockConnectorCall);

        const mockResponse: ConnectorTestResponse = {
          success: false,
          error: "Connector call failed: Connection timeout"
        };

        mockSimplifierClient.testConnectorCall.mockResolvedValue(mockResponse);

        mockWrapToolResult.mockImplementation(async (_caption, fn) => {
          const result = await fn();
          expect(result.success).toBe(false);
          expect(result.error).toBe("Connector call failed: Connection timeout");
          return {
            content: [{ type: "text", text: JSON.stringify(result, null, 2) }]
          };
        });

        await toolHandler(testParams);

        expect(mockSimplifierClient.getConnectorCall).toHaveBeenCalledWith("TestConnector", "failingCall");
        expect(mockSimplifierClient.testConnectorCall).toHaveBeenCalledWith(
          "TestConnector",
          "failingCall",
          { parameters: [] },
          "MCP Tool: connector-call-test"
        );
      });

      it('should handle connector call with message field on failure', async () => {
        const testParams = {
          connectorName: "TestConnector",
          callName: "failingCall",
          parameters: []
        };

        // Mock the connector call details
        const mockConnectorCall: SimplifierConnectorCallDetails = {
          name: "failingCall",
          description: "Failing call",
          validateIn: true,
          validateOut: true,
          async: false,
          autoGenerated: false,
          editable: true,
          executable: true,
          connectorName: "TestConnector",
          connectorCallParameters: []
        };

        mockSimplifierClient.getConnectorCall.mockResolvedValue(mockConnectorCall);

        const mockResponse: ConnectorTestResponse = {
          success: false,
          message: "Invalid parameters provided"
        };

        mockSimplifierClient.testConnectorCall.mockResolvedValue(mockResponse);

        mockWrapToolResult.mockImplementation(async (_caption, fn) => {
          const result = await fn();
          expect(result.success).toBe(false);
          expect(result.error).toBe("Invalid parameters provided");
          return {
            content: [{ type: "text", text: JSON.stringify(result, null, 2) }]
          };
        });

        await toolHandler(testParams);
      });

      it('should handle connector call with neither error nor message on failure', async () => {
        const testParams = {
          connectorName: "TestConnector",
          callName: "failingCall",
          parameters: []
        };

        // Mock the connector call details
        const mockConnectorCall: SimplifierConnectorCallDetails = {
          name: "failingCall",
          description: "Failing call",
          validateIn: true,
          validateOut: true,
          async: false,
          autoGenerated: false,
          editable: true,
          executable: true,
          connectorName: "TestConnector",
          connectorCallParameters: []
        };

        mockSimplifierClient.getConnectorCall.mockResolvedValue(mockConnectorCall);

        const mockResponse: ConnectorTestResponse = {
          success: false
        };

        mockSimplifierClient.testConnectorCall.mockResolvedValue(mockResponse);

        mockWrapToolResult.mockImplementation(async (_caption, fn) => {
          const result = await fn();
          expect(result.success).toBe(false);
          expect(result.error).toBe("Unknown error");
          return {
            content: [{ type: "text", text: JSON.stringify(result, null, 2) }]
          };
        });

        await toolHandler(testParams);
      });

      it('should handle client errors (404, 400, 500)', async () => {
        const testParams = {
          connectorName: "NonExistentConnector",
          callName: "nonExistentCall",
          parameters: []
        };

        mockSimplifierClient.testConnectorCall.mockRejectedValue(
          new Error("Connector 'NonExistentConnector' or call 'nonExistentCall' not found")
        );

        mockWrapToolResult.mockImplementation(async (caption, fn) => {
          try {
            await fn();
            return { content: [{ type: "text", text: "Success" }] };
          } catch (error) {
            return {
              content: [{
                type: "text",
                text: JSON.stringify({ error: `Tool ${caption} failed: ${error}` })
              }]
            };
          }
        });

        await toolHandler(testParams);

        expect(mockWrapToolResult).toHaveBeenCalledWith(
          "test connector call NonExistentConnector.nonExistentCall",
          expect.any(Function)
        );
      });

      it('should format successful response correctly', async () => {
        const testParams = {
          connectorName: "TestConnector",
          callName: "successCall",
          parameters: [{ name: "input", value: "test" }]
        };

        // Mock the connector call details
        const mockConnectorCall: SimplifierConnectorCallDetails = {
          name: "successCall",
          description: "Success call",
          validateIn: true,
          validateOut: true,
          async: false,
          autoGenerated: false,
          editable: true,
          executable: true,
          connectorName: "TestConnector",
          connectorCallParameters: [
            {
              name: "input",
              isInput: true,
              dataType: { name: "String", category: "base" },
              optional: false,
              position: 0
            }
          ]
        };

        const mockDataType = {
          id: "string-id",
          name: "String",
          category: "base",
          description: "String type",
          baseType: "string",
          isStruct: false,
          fields: [],
          properties: []
        };

        mockSimplifierClient.getConnectorCall.mockResolvedValue(mockConnectorCall);
        mockSimplifierClient.getDataTypeById = jest.fn().mockResolvedValue(mockDataType);

        const mockResponse: ConnectorTestResponse = {
          success: true,
          result: { result: { output: "processed test" } }
        };

        mockSimplifierClient.testConnectorCall.mockResolvedValue(mockResponse);

        mockWrapToolResult.mockImplementation(async (_caption, fn) => {
          const result = await fn();
          expect(result).toEqual({
            success: true,
            message: "Connector call 'successCall' executed successfully",
            result: {result: {output: "processed test"}}
          });
          return {
            content: [{ type: "text", text: JSON.stringify(result, null, 2) }]
          };
        });

        await toolHandler(testParams);
      });

      it('should format failure response correctly', async () => {
        const testParams = {
          connectorName: "TestConnector",
          callName: "failCall",
          parameters: []
        };

        // Mock the connector call details
        const mockConnectorCall: SimplifierConnectorCallDetails = {
          name: "failCall",
          description: "Fail call",
          validateIn: true,
          validateOut: true,
          async: false,
          autoGenerated: false,
          editable: true,
          executable: true,
          connectorName: "TestConnector",
          connectorCallParameters: []
        };

        mockSimplifierClient.getConnectorCall.mockResolvedValue(mockConnectorCall);

        const mockResponse: ConnectorTestResponse = {
          success: false,
          error: "Execution error"
        };

        mockSimplifierClient.testConnectorCall.mockResolvedValue(mockResponse);

        mockWrapToolResult.mockImplementation(async (_caption, fn) => {
          const result = await fn();
          expect(result).toEqual({
            success: false,
            message: "Connector call 'failCall' execution failed",
            error: "Execution error"
          });
          return {
            content: [{ type: "text", text: JSON.stringify(result, null, 2) }]
          };
        });

        await toolHandler(testParams);
      });
    });
  });

  describe('connector-call-delete tool', () => {
    let deleteCallToolHandler: Function;

    beforeEach(() => {
      registerConnectorTools(mockServer, mockSimplifierClient);
      // Get the delete call tool handler (fourth tool registered)
      deleteCallToolHandler = mockServer.tool.mock.calls[3][4];
    });

    describe('delete call tool registration', () => {
      it('should register delete call tool with correct schema', () => {
        registerConnectorTools(mockServer, mockSimplifierClient);

        const deleteCallToolCall = mockServer.tool.mock.calls[3];
        const schema = deleteCallToolCall[2];

        // Test required fields exist
        expect(schema.connectorName).toBeDefined();
        expect(schema.callName).toBeDefined();

        // Test valid data passes validation
        expect(() => schema.connectorName.parse("TestConnector")).not.toThrow();
        expect(() => schema.callName.parse("testCall")).not.toThrow();

        // Test that fields are required
        expect(() => schema.connectorName.parse(undefined)).toThrow();
        expect(() => schema.callName.parse(undefined)).toThrow();
        expect(() => schema.connectorName.parse(null)).toThrow();
        expect(() => schema.callName.parse(null)).toThrow();
      });
    });

    describe('delete call tool handler', () => {
      it('should successfully delete a connector call', async () => {
        const testParams = {
          connectorName: "TestConnector",
          callName: "testCall"
        };

        const expectedResponse = "Connector call 'testCall' deleted successfully from Connector 'TestConnector'";

        mockSimplifierClient.deleteConnectorCall.mockResolvedValue(expectedResponse);

        mockWrapToolResult.mockImplementation(async (_caption, fn) => {
          const result = await fn();
          return {
            content: [{type: "text", text: JSON.stringify(result, null, 2)}]
          };
        });

        await deleteCallToolHandler(testParams);

        expect(mockSimplifierClient.deleteConnectorCall).toHaveBeenCalledWith("TestConnector", "testCall", "MCP Tool: connector-call-delete");
        expect(mockWrapToolResult).toHaveBeenCalledWith(
          "delete connector call TestConnector.testCall",
          expect.any(Function)
        );
      });

      it('should handle errors when connector call is not deletable', async () => {
        const testParams = {
          connectorName: "TestConnector",
          callName: "protectedCall"
        };

        mockSimplifierClient.deleteConnectorCall.mockRejectedValue(
          new Error("Connector call 'protectedCall' cannot be deleted: still in use")
        );

        mockWrapToolResult.mockImplementation(async (caption, fn) => {
          try {
            await fn();
            return {content: [{type: "text", text: "Success"}]};
          } catch (error) {
            return {
              content: [{
                type: "text",
                text: JSON.stringify({error: `Tool ${caption} failed: ${error}`})
              }]
            };
          }
        });

        await deleteCallToolHandler(testParams);

        expect(mockSimplifierClient.deleteConnectorCall).toHaveBeenCalledWith("TestConnector", "protectedCall", "MCP Tool: connector-call-delete");
      });

      it('should return the string response from API on successful deletion', async () => {
        const testParams = {
          connectorName: "TestConnector",
          callName: "testCall"
        };

        const expectedResponse = "Deleted successfully";

        mockSimplifierClient.deleteConnectorCall.mockResolvedValue(expectedResponse);

        mockWrapToolResult.mockImplementation(async (_caption, fn) => {
          const result = await fn();
          expect(result).toBe("Deleted successfully");
          return {
            content: [{type: "text", text: JSON.stringify(result, null, 2)}]
          };
        });

        await deleteCallToolHandler(testParams);

        expect(mockWrapToolResult).toHaveBeenCalled();
      });

    });


    describe('connector-delete tool', () => {
      let deleteConnectorToolHandler: Function;

      beforeEach(() => {
        registerConnectorTools(mockServer, mockSimplifierClient);
        // Get the delete connector tool handler (fifth tool registered)
        deleteConnectorToolHandler = mockServer.tool.mock.calls[4][4];
      });

      describe('delete connector tool registration', () => {
        it('should register delete connector tool with correct schema', () => {
          registerConnectorTools(mockServer, mockSimplifierClient);

          const deleteConnectorToolCall = mockServer.tool.mock.calls[4];
          const schema = deleteConnectorToolCall[2];

          // Test required fields exist
          expect(schema.connectorName).toBeDefined();

          // Test valid data passes validation
          expect(() => schema.connectorName.parse("TestConnector")).not.toThrow();

          // Test that connectorName is required
          expect(() => schema.connectorName.parse(undefined)).toThrow();
          expect(() => schema.connectorName.parse(null)).toThrow();
        });
      });

      describe('delete connector tool handler', () => {
        it('should successfully delete a connector', async () => {
          const testParams = {
            connectorName: "TestConnector"
          };

          const expectedResponse = "Connector 'TestConnector' deleted successfully";

          mockSimplifierClient.deleteConnector.mockResolvedValue(expectedResponse);

          mockWrapToolResult.mockImplementation(async (_caption, fn) => {
            const result = await fn();
            return {
              content: [{type: "text", text: JSON.stringify(result, null, 2)}]
            };
          });

          await deleteConnectorToolHandler(testParams);

          expect(mockSimplifierClient.deleteConnector).toHaveBeenCalledWith("TestConnector", "MCP Tool: connector-delete");
          expect(mockWrapToolResult).toHaveBeenCalledWith(
            "delete connector TestConnector",
            expect.any(Function)
          );
        });

        it('should handle errors when connector is not deletable', async () => {
          const testParams = {
            connectorName: "ProtectedConnector"
          };

          mockSimplifierClient.deleteConnector.mockRejectedValue(
            new Error("Connector 'ProtectedConnector' cannot be deleted: still in use by Business Objects")
          );

          mockWrapToolResult.mockImplementation(async (caption, fn) => {
            try {
              await fn();
              return {content: [{type: "text", text: "Success"}]};
            } catch (error) {
              return {
                content: [{
                  type: "text",
                  text: JSON.stringify({error: `Tool ${caption} failed: ${error}`})
                }]
              };
            }
          });

          await deleteConnectorToolHandler(testParams);

          expect(mockSimplifierClient.deleteConnector).toHaveBeenCalledWith("ProtectedConnector", "MCP Tool: connector-delete");
        });

        it('should return the string response from API on successful deletion', async () => {
          const testParams = {
            connectorName: "TestConnector"
          };

          const expectedResponse = "Deleted successfully";

          mockSimplifierClient.deleteConnector.mockResolvedValue(expectedResponse);

          mockWrapToolResult.mockImplementation(async (_caption, fn) => {
            const result = await fn();
            expect(result).toBe("Deleted successfully");
            return {
              content: [{type: "text", text: JSON.stringify(result, null, 2)}]
            };
          });

          await deleteConnectorToolHandler(testParams);

          expect(mockWrapToolResult).toHaveBeenCalled();
        });
      });
    });
  });
});
