import {McpServer} from "@modelcontextprotocol/sdk/server/mcp.js";
import {z} from "zod";
import type { ConnectorTestParameter, ConnectorTestRequest } from "../client/types.js";
import {SimplifierClient} from "../client/simplifier-client.js";
import {SimplifierConnectorCallUpdate, SimplifierConnectorUpdate} from "../client/types.js";
import {readFile} from "../resourceprovider.js";
import {wrapToolResult} from "./toolresult.js";

export function registerConnectorTools(server: McpServer, simplifier: SimplifierClient): void {

  server.tool("connector-update",
    readFile("tools/docs/create-or-update-connector.md"),
    {
      name: z.string(),
      description: z.string().optional().default(""),
      connectorType: z.string(),
      active: z.boolean().optional().default(true),
      timeoutTime: z.number().optional().default(60)
        .describe(`maximum duration of a call in seconds`),
      endpointConfiguration: z.object({
        endpoint: z.string()
          .describe(`The name of an existing endpoint, defined at the Simplifier server landscape`),
        certificates: z.array(z.string()),
        configuration: z.any().optional()
          .describe(`The properties, defined by this object are specific to the chosen connectorType`),
        loginMethodName: z.string().optional()
          .describe(`The name of an existing login method, available on the Simplifier server`),
      }).optional()
        .describe(
          `On creating a new connector, an endpoint configuration is mandatory. 
          On updating a Connector:
          * endpoint configuration may be omitted if it is not intended to change. 
          * a new endpoint configuration can be added by using a new endpoint name. 
          * one endpoint configuration can be changed by using the name property of an existing configuration. 
        `),
      tags: z.array(z.string()).optional().default([]),
      projectsBefore: z.array(z.string()).optional().default([])
        .describe('Project names before the change. Use empty array [] when creating new Connectors, or provide current projects when updating.'),
      projectsAfterChange: z.array(z.string()).optional().default([])
        .describe('Project names to assign the Connector to. Required for tracking project assignments.')
    },
    {
      title: "Create or update a Connector",
      readOnlyHint: false,
      destructiveHint: false,
      idempotentHint: false,
      openWorldHint: true
    },
    async ( {name, description, connectorType, active, timeoutTime, endpointConfiguration, tags, projectsBefore, projectsAfterChange}) => {
      return wrapToolResult( `create or update Connector ${name}`, async () => {
        let oExisting: any;
        try { oExisting = await simplifier.getConnector(name) } catch {}
        const oConnectorData = {
          name: name,
          description: description,
          connectorType: connectorType,
          active: active,
          timeoutTime: timeoutTime,
          endpointConfiguration: endpointConfiguration,
          tags: tags,
          assignedProjects: {
            projectsBefore: projectsBefore,
            projectsAfterChange: projectsAfterChange
          }
        } as SimplifierConnectorUpdate

        if (oExisting?.name) {
          return simplifier.updateConnector(oConnectorData);
        } else {
          if (!oConnectorData.endpointConfiguration) {
            throw new Error('endpointConfiguration is required on creating a new connector!');
          }
          return simplifier.createConnector(oConnectorData)
        }
      })
    });


  server.tool("connector-call-update",
    readFile("tools/docs/create-or-update-connectorcall.md"),
    {
      connectorName: z.string()
        .describe(`Name of the Connector to modify calls`),
      connectorCallName: z.string()
        .describe(`Name of the Connector call to be added or modified`),
      description: z.string().default(""),
      validateIn: z.boolean().default(true),
      validateOut: z.boolean().default(true),
      async: z.boolean().default(false),
      autoGenerated: z.boolean().default(false),
      connectorCallParameters: z.array(z.object({
        name: z.string()
          .describe(`Parameter name may contain '/' or '[]', indicating it's position inside a JSON object or array` ),
        alias: z.string().optional()
          .describe(`optional alias name`),
        isInput: z.boolean()
          .describe(`If true, the parameter represents an input of the connector call. Set this to false in order to define an output parameter.`),
        constValue: z.string().optional()
          .describe(`If constValue is given, the value is fixed and cannot be changed by the caller`),
        dataType: z.object({
          name: z.string()
            .describe(`Datatype name'`),
          nameSpace: z.string().optional()
            .describe(`Datatype namespace`),
          category: z.enum(['base', 'domain', 'collection', 'structure'])
            .describe(`Datatype category`),
        }),
        optional: z.boolean().default(false)
          .describe(`If true, the parameter is optional`),
        position: z.number().default(0)
          .describe(`Row position for display the parameter in the UI.`),
      })).optional().default([])
        .describe(`Call Parameters define the input and output arguments, specific to the connector type.`)
    },
    {
      title: "Create or update a Connector Call",
      readOnlyHint: false,
      destructiveHint: false,
      idempotentHint: false,
      openWorldHint: true
    },
    async (oArgs) => {
      return wrapToolResult(`create or update Connector call ${oArgs.connectorName}.${oArgs.connectorCallName}`, async () => {
        let oExisting: any;
        try {
          oExisting = await simplifier.getConnectorCall(oArgs.connectorName, oArgs.connectorCallName);
        } catch {
        }
        const oConnectorCallData = {
          name: oArgs.connectorCallName,
          description: oArgs.description,
          validateIn: oArgs.validateIn,
          validateOut: oArgs.validateOut,
          async: oArgs.async,
          autoGenerated: oArgs.autoGenerated,
          connectorCallParameters: oArgs.connectorCallParameters,
        } as SimplifierConnectorCallUpdate

        if (oExisting?.name) {
          return simplifier.updateConnectorCall(oArgs.connectorName, oConnectorCallData);
        } else {
          return simplifier.createConnectorCall(oArgs.connectorName, oConnectorCallData);
        }
      });
    }
  );



  const connectorTestDescription = `#Test a Connector Call

Execute a connector call with provided input parameters for testing purposes.
This allows you to test connector calls with real data and see the results.

**Parameter Usage**:
- Each parameter requires a "name" (the field name) and a "value" (the actual data)
- Parameter names must match the connector call's defined parameters
- Values can be any JSON value (string, number, boolean, object, array). The connector call specifies the expected input data type.
`;

  server.tool("connector-call-test",
    connectorTestDescription,
    {
      connectorName: z.string(),
      callName: z.string(),
      parameters: z.array(z.object({
        name: z.string().describe("Parameter name"),
        value: z.unknown().describe("Parameter value - can be any JSON value")
      })).optional().default([]).describe("Input parameters for the connector call")
    },
    {
      title: "Test a Connector Call",
      readOnlyHint: true,
      destructiveHint: false,
      idempotentHint: true,
      openWorldHint: false
    }, async ({ connectorName, callName, parameters }) => {
      return wrapToolResult(`test connector call ${connectorName}.${callName}`, async () => {
        // Convert user input to API format
        const testParameters: ConnectorTestParameter[] = (parameters || []).map(p => ({
          name: p.name,
          value: p.value
        }));

        const testRequest: ConnectorTestRequest = {
          parameters: testParameters
        };

        const result = await simplifier.testConnectorCall(connectorName, callName, testRequest);
        // return result;

        // Format the response nicely
        if (result.success) {
          return {
            success: true,
            message: `Connector call '${callName}' executed successfully`,
            result: result.result,
            executedWith: {
              connector: connectorName,
              call: callName,
              parameters: testParameters
            }
          };
        } else {
          return {
            success: false,
            message: `Connector call '${callName}' execution failed`,
            error: result.error || result.message || "Unknown error",
            executedWith: {
              connector: connectorName,
              call: callName,
              parameters: testParameters
            }
          };
        }
      });
    });
}